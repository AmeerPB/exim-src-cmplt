Backport of:

From 4e9ed49f8f12eb331b29bd5b6dc3693c520fddc2 Mon Sep 17 00:00:00 2001
From: Jeremy Harris <jgh146exb@wizmail.org>
Date: Wed, 31 Aug 2022 15:37:40 +0100
Subject: [PATCH] Fix $regex<n> use-after-free.  Bug 2915

---
 doc/doc-txt/ChangeLog           |  8 +++++++-
 src/src/exim.c                  |  4 +---
 src/src/expand.c                |  2 +-
 src/src/functions.h             |  1 +
 src/src/globals.c               |  2 +-
 src/src/regex.c                 | 29 ++++++++++++++++++-----------
 src/src/smtp_in.c               |  2 ++
 test/confs/4002                 | 10 ++++++++++
 test/mail/4002.userx            |  7 +++++++
 test/scripts/4000-scanning/4002 |  7 +++++++
 10 files changed, 55 insertions(+), 17 deletions(-)

#diff --git a/doc/doc-txt/ChangeLog b/doc/doc-txt/ChangeLog
#index 6a4e10915..ba5bd23d9 100644
#--- a/doc/doc-txt/ChangeLog
#+++ b/doc/doc-txt/ChangeLog
#@@ -30,11 +30,17 @@ JH/07 OpenSSL Fix auto-reload of changed server OCSP proof. Previously, if
#       the file with the proof had an unchanged name, the new proof(s) were
#       loaded on top of the old ones (and nover used; the old ones were stapled).
# 
#+JH/08 Bug 2915: Fix use-after-free for $regex<n> variables. Previously when
#+      more than one message arrived in a single connection a reference from
#+      the earlier message could be re-used.  Often a sigsegv resulted.
#+      These variables were introduced in Exim 4.87.
#+      Debug help from Graeme Fowler.
#+
# 
# Exim version 4.96
# -----------------
# 
#-JH/01 Move the wait-for-next-tick (needed for unique messmage IDs) from
#+JH/01 Move the wait-for-next-tick (needed for unique message IDs) from
#       after reception to before a subsequent reception.  This should
#       mean slightly faster delivery, and also confirmation of reception
#       to senders.
--- a/src/exim.c
+++ b/src/exim.c
@@ -1908,8 +1908,6 @@ regex_whitelisted_macro =
   regex_must_compile(US"^[A-Za-z0-9_/.-]*$", FALSE, TRUE);
 #endif
 
-for (i = 0; i < REGEX_VARS; i++) regex_vars[i] = NULL;
-
 /* If the program is called as "mailq" treat it as equivalent to "exim -bp";
 this seems to be a generally accepted convention, since one finds symbolic
 links called "mailq" in standard OS configurations. */
@@ -5924,7 +5922,7 @@ moreloop:
   deliver_localpart_data = deliver_domain_data =
   recipient_data = sender_data = NULL;
   acl_var_m = NULL;
-  for(int i = 0; i < REGEX_VARS; i++) regex_vars[i] = NULL;
+  regex_vars_clear();
 
   store_reset(reset_point);
   }
--- a/src/expand.c
+++ b/src/expand.c
@@ -1886,7 +1886,7 @@ else if (Ustrncmp(name, "r_", 2) == 0)
   return node ? node->data.ptr : strict_acl_vars ? NULL : US"";
   }
 
-/* Handle $auth<n> variables. */
+/* Handle $auth<n>, $regex<n> variables. */
 
 if (Ustrncmp(name, "auth", 4) == 0)
   {
--- a/src/functions.h
+++ b/src/functions.h
@@ -430,6 +430,7 @@ extern int     regex(const uschar **);
 #endif
 extern BOOL    regex_match_and_setup(const pcre *, const uschar *, int, int);
 extern const pcre *regex_must_compile(const uschar *, BOOL, BOOL);
+extern void    regex_vars_clear(void);
 extern void    retry_add_item(address_item *, uschar *, int);
 extern BOOL    retry_check_address(const uschar *, host_item *, uschar *, BOOL,
                  uschar **, uschar **);
--- a/src/globals.c
+++ b/src/globals.c
@@ -1324,7 +1324,7 @@ const pcre *regex_EARLY_PIPE   = NULL;
 #endif
 const pcre *regex_ismsgid      = NULL;
 const pcre *regex_smtp_code    = NULL;
-uschar *regex_vars[REGEX_VARS];
+uschar *regex_vars[REGEX_VARS] = { 0 };;
 #ifdef WHITELIST_D_MACROS
 const pcre *regex_whitelisted_macro = NULL;
 #endif
--- a/src/regex.c
+++ b/src/regex.c
@@ -87,18 +87,28 @@ for(pcre_list * ri = re_list_head; ri; r
 return FAIL;
 }
 
+
+/* reset expansion variables */
+void
+regex_vars_clear(void)
+{
+regex_match_string = NULL;
+for (int i = 0; i < REGEX_VARS; i++) regex_vars[i] = NULL;
+}
+
+
+
 int
-regex(const uschar **listptr)
+regex(const uschar ** listptr)
 {
 unsigned long mbox_size;
-FILE *mbox_file;
-pcre_list *re_list_head;
-uschar *linebuffer;
+FILE * mbox_file;
+pcre_list * re_list_head;
+uschar * linebuffer;
 long f_pos = 0;
 int ret = FAIL;
 
-/* reset expansion variable */
-regex_match_string = NULL;
+regex_vars_clear();
 
 if (!mime_stream)				/* We are in the DATA ACL */
   {
@@ -160,14 +170,13 @@ return ret;
 int
 mime_regex(const uschar **listptr)
 {
-pcre_list *re_list_head = NULL;
-FILE *f;
-uschar *mime_subject = NULL;
+pcre_list * re_list_head = NULL;
+FILE * f;
+uschar * mime_subject = NULL;
 int mime_subject_len = 0;
 int ret;
 
-/* reset expansion variable */
-regex_match_string = NULL;
+regex_vars_clear();
 
 /* precompile our regexes */
 if (!(re_list_head = compile(*listptr)))
--- a/src/smtp_in.c
+++ b/src/smtp_in.c
@@ -2155,8 +2155,10 @@ prdr_requested = FALSE;
 #ifdef SUPPORT_I18N
 message_smtputf8 = FALSE;
 #endif
+regex_vars_clear();
 body_linecount = body_zerocount = 0;
 
+lookup_value = NULL;				/* Can be set by ACL */
 sender_rate = sender_rate_limit = sender_rate_period = NULL;
 ratelimiters_mail = NULL;           /* Updated by ratelimit ACL condition */
                    /* Note that ratelimiters_conn persists across resets. */
